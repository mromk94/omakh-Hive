{
  "id": "0d586da5-c24e-43ff-8b24-73ee6f79187b",
  "title": "[System Analysis] Add Request Rate Limiting",
  "description": "{\n  \"title\": \"Implement Redis-based Rate Limiting\",\n  \"description\": \"Add rate limiting middleware using Redis to protect API endpoints from abuse. Implementation uses sliding window algorithm with configurable limits per endpoint and user/IP. Includes fallback mechanism and detailed logging.\",\n  \"files\": [\n    {\n      \"path\": \"app/middleware/rate_limiter.py\",\n      \"changes\": \"Create new rate limiter middleware using Redis\",\n      \"code\": \"\"\"\nfrom fastapi import FastAPI, Request, HTTPException\nfrom redis import Redis\nfrom typing import Optional\nimport time\nimport json\nfrom logging import getLogger\nfrom functools import wraps\n\nlogger = getLogger(__name__)\n\nclass RateLimiter:\n    def __init__(\n        self,\n        redis_client: Redis,\n        prefix: str = 'ratelimit',\n        default_limit: int = 100,\n        default_window: int = 60\n    ):\n        self.redis = redis_client\n        self.prefix = prefix\n        self.default_limit = default_limit\n        self.default_window = default_window\n\n    async def is_rate_limited(\n        self,\n        key: str,\n        limit: Optional[int] = None,\n        window: Optional[int] = None\n    ) -> tuple[bool, dict]:\n        limit = limit or self.default_limit\n        window = window or self.default_window\n        \n        try:\n            current = int(time.time())\n            key = f\"{self.prefix}:{key}\"\n            \n            pipeline = self.redis.pipeline()\n            pipeline.zremrangebyscore(key, 0, current - window)\n            pipeline.zadd(key, {str(current): current})\n            pipeline.zcard(key)\n            pipeline.expire(key, window)\n            _, _, count, _ = pipeline.execute()\n            \n            return count > limit, {\n                'limit': limit,\n                'remaining': max(0, limit - count),\n                'reset': current + window,\n                'window': window\n            }\n        except Exception as e:\n            logger.error(f\"Rate limiter error: {str(e)}\")\n            return False, {}  # Fail open on errors\n\ndef rate_limit(\n    limit: Optional[int] = None,\n    window: Optional[int] = None,\n    key_func: Optional[callable] = None\n):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(request: Request, *args, **kwargs):\n            limiter = request.app.state.rate_limiter\n            \n            # Get rate limit key (default to IP address)\n            if key_func:\n                key = key_func(request)\n            else:\n                key = request.client.host\n                \n            is_limited, info = await limiter.is_rate_limited(\n                key=key,\n                limit=limit,\n                window=window\n            )\n            \n            # Set rate limit headers\n            headers = {\n                'X-RateLimit-Limit': str(info.get('limit', '')),\n                'X-RateLimit-Remaining': str(info.get('remaining', '')),\n                'X-RateLimit-Reset': str(info.get('reset', ''))\n            }\n            \n            if is_limited:\n                raise HTTPException(\n                    status_code=429,\n                    detail=\"Too many requests\",\n                    headers=headers\n                )\n                \n            response = await func(request, *args, **kwargs)\n            \n            # Add headers to response\n            for header, value in headers.items():\n                response.headers[header] = value\n                \n            return response\n        return wrapper\n    return decorator\n\"\"\"\n    },\n    {\n      \"path\": \"app/main.py\",\n      \"changes\": \"Add rate limiter initialization and example usage\",\n      \"code\": \"\"\"\nfrom fastapi import FastAPI\nfrom redis import Redis\nfrom app.middleware.rate_limiter import RateLimiter, rate_limit\n\napp = FastAPI()\n\n# Initialize Redis and rate limiter\nredis_client = Redis(\n    host='localhost',\n    port=6379,\n    db=0,\n    decode_responses=True\n)\n\napp.state.rate_limiter = RateLimiter(\n    redis_client=redis_client,\n    prefix='myapp:ratelimit',\n    default_limit=100,\n    default_window=60\n)\n\n# Example protected endpoint\n@app.get(\"/api/protected\")\n@rate_limit(limit=5, window=60)\nasync def protected_endpoint(request: Request):\n    return {\"message\": \"Success\"}\n\n# Example with custom key function\ndef custom_key_func(request: Request) -> str:\n    return request.headers.get('X-API-Key', request.client.host)\n\n@app.get(\"/api/custom-limited\")\n@rate_limit(limit=10, window=60, key_func=custom_key_func)\nasync def custom_limited_endpoint(request: Request):\n    return {\"message\": \"Success\"}\n\"\"\"\n    },\n    {\n      \"path\": \"tests/test_rate_limiter.py\",\n      \"changes\": \"Add unit tests for rate limiter\",\n      \"code\": \"\"\"\nimport pytest\nfrom fastapi.testclient import TestClient\nfrom app.main import app\nimport time\n\nclient = TestClient(app)\n\ndef test_rate_limit_basic():\n    # Test within limits\n    for _ in range(5):\n        response = client.get(\"/api/protected\")\n        assert response.status_code == 200\n        \n    # Test exceeding limits\n    response = client.get(\"/api/protected\")\n    assert response.status_code == 429\n    assert \"Too many requests\" in response.json()[\"detail\"]\n    \n    # Verify headers\n    assert \"X-RateLimit-Limit\" in response.headers\n    assert \"X-RateLimit-Remaining\" in response.headers\n    assert \"X-RateLimit-Reset\" in response.headers\n\n@pytest.mark.asyncio\nasync def test_rate_limit_window():\n    # Test rate limit reset after window\n    response = client.get(\"/api/protected\")\n    assert response.status_code == 200\n    \n    # Wait for window to expire\n    time.sleep(60)\n    \n    # Should work again\n    response = client.get(\"/api/protected\")\n    assert response.status_code == 200\n\"\"\"\n    }\n  ],\n  \"testing_steps\": [\n    \"Run unit tests: pytest tests/test_rate_limiter.py\",\n    \"Test rate limits with concurrent requests using Apache Bench or similar tool\",\n    \"Verify Redis connection and key expiration\",\n    \"Test failover behavior when Redis is unavailable\",\n    \"Verify correct header propagation\",\n    \"Load test with expected traffic patterns\"\n  ],\n  \"deployment_notes\": [\n    \"Ensure Redis is properly configured with appropriate memory limits\",\n    \"Monitor Redis memory usage and implement key eviction policies\",\n    \"Consider implementing circuit breaker for Redis connection\",\n    \"Add monitoring for rate limit hits and Redis performance\",\n    \"Document rate limit values in API documentation\",\n    \"Consider implementing rate limit notification system for affected users\"\n  ],\n  \"risk_level\": \"medium\",\n  \"estimated_improvement\": {\n    \"security\": \"Protection against DoS attacks and API abuse\",\n    \"stability\": \"Prevents resource exhaustion\",\n    \"metrics\": {\n      \"max_requests_per_ip\": \"100/minute by default\",\n      \"redis_memory_usage\": \"~1MB per 10k active users\",\n      \"response_time_impact\": \"<5ms per request\"\n    }\n  }\n}",
  "priority": "high",
  "risk_level": "medium",
  "files_to_modify": [],
  "tests_required": [],
  "rollback_plan": "",
  "estimated_impact": "See description",
  "status": "sandbox_deployed",
  "created_at": "2025-10-13T14:45:07.640518",
  "created_by": "system_analysis",
  "metadata": {
    "source": "system_analysis",
    "recommendation": "Add Request Rate Limiting",
    "testing_steps": [],
    "deployment_notes": [],
    "estimated_improvement": "See description"
  },
  "sandbox_path": "/Users/mac/CascadeProjects/omakh-Hive/sandbox/0d586da5-c24e-43ff-8b24-73ee6f79187b",
  "test_results": null,
  "admin_notes": null,
  "approved_by": null,
  "approved_at": null,
  "applied_at": null,
  "sandbox_deployed_at": "2025-10-13T14:59:03.532184",
  "files_applied": []
}